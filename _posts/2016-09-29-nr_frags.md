---
layout: default
title: 结构体 skb_shared_info 成员变量 nr_frags 和 frags
---
# 结构体 skb_shared_info 成员变量 nr_frags 和 frags 

## 结构体声明
```
struct skb_shared_info {
	atomic_t    dataref;
	unsigned short  nr_frags;   
	unsigned short  gso_size;
	/* Warning: this field is not always filled in (UFO)! */
	unsigned short  gso_segs; 
	unsigned short  gso_type;
	__be32          ip6_frag_id;
	struct sk_buff  *frag_list;
	skb_frag_t  frags[MAX_SKB_FRAGS];
};   
```
*nr_frags* 和 *frags* 用于支持 Scatter/Gather I/O buffer，这样SKB的数据部分不需要都
放在线性内存空间而是放在 page. 

## 在发送路径上的应用
在函数 *tcp_sendmsg* 中, 用于存放从应用层拷贝过来的数据。
```
/*
 skb_tailroom 用于返回此SKB的skb->tail到skb->end之间的空闲距离，如果有的话，   
 可以利用。
 */
if (skb_tailroom(skb) > 0) {
	/* We have some space in skb head. Superb! */
    if (copy > skb_tailroom(skb))
    	copy = skb_tailroom(skb);

    /*
     skb_add_data 拷贝数据的同时计算checksum.
    */
    if ((err = skb_add_data(skb, from, copy)) != 0)
    	goto do_fault;
    } else {
    	int merge = 0;  
		/*
		 i 是 frags 已经使用的数目。
		*/
        int i = skb_shinfo(skb)->nr_frags;	  
        struct page *page = TCP_PAGE(sk);   
        int off = TCP_OFF(sk);  

		/*
		 skb_can_coalesce 检查SKB的frags中最后一个page是否有空闲空间。
		 */
        if (skb_can_coalesce(skb, i, page, off) &&
                    off != PAGE_SIZE) {
             merge = 1;
        } else if (i == MAX_SKB_FRAGS ||
        	(!i &&
            !(sk->sk_route_caps & NETIF_F_SG))) {
                /*
                 执行到这里说明 frags的使用到达上限，需要重新分配一个sk_buff.
                */
                tcp_mark_push(tp, skb);
                goto new_segment;
        } else if (page) {
        	/*  a new page is needed */
            if (off == PAGE_SIZE) {
            	put_page(page);
                TCP_PAGE(sk) = page = NULL;
                off = 0;
            }
        } else
        	off = 0;
```

## 在接收路径上的应用
函数 skb_copy_datagram_iovec


